== Authentication
Once a user is registered in your system, he or she can use the app. Depending on the scenario, you can prompt users to authenticate before they start using the app or you can prompt them before performing an authenticated action inside of your app. For example, before a banking app sends the transfer money request to the server, you want to make sure it is the user, rather than an impersonator, attempting to perform the transaction.

The authentication flow looks similar to the registration flow. The primary differences are:
* Authentication doesnâ€™t require user information
* Authentication creates an assertion signed by the previously generated private key that is associated with the relying party rather than signing with the attestation certificate.

image::fido2_authentication.png[]

First, the app makes the initial authentication request to the /authenticate endpoint of the REST API. The request is sent to the service layer which calls the startAuthentication() method. The server generates a challenge and returns an AssertionResponse. The parameters received from the server are then passed to the get() call via the PublicKeyCredentialRequestOptions data structure.

.https://github.com/Yubico/java-webauthn-server/blob/01f5295ee2522ad70b9a6199997a0cad7bffdad2/webauthn-server-demo/src/main/java/demo/webauthn/WebAuthnServer.java#L394[Start authentication]
[source, java]
----
public Either<List<String>, AssertionRequest> startAuthentication(Optional<String> username) {
    logger.trace("startAuthentication username: {}", username);

    if (username.isPresent() && userStorage.getRegistrationsByUsername(username.get()).isEmpty()) {
        return Either.left(Collections.singletonList("The username \"" + username.get() + "\" is not registered."));
    } else {
        AssertionRequest request = new AssertionRequest(
            challengeGenerator.generateChallenge(),
            rp.startAssertion(
                StartAssertionOptions.builder()
                    .username(username)
                    .build()
            )
        );

        assertRequestStorage.put(request.getRequestId(), request);

        return Either.right(request);
    }
}
----    

.WebAuthn get parameters
[source, javascript]
----
var options = {
  "challenge": "0-EvZd59EjuHAP47NZ...",     // The challenge the authenticator signs as part of the AssertionResponse
  "rpId": "demo.yubico.com",                // Relying party identifier claimed by the caller
  "allowCredentials": [                     // List of public key credentials acceptable to the caller, can be omitted for usernameless authentication
    {
      "type": "public-key",                 // Only one type "public-key"
      "id": "Co-lzCxusMUGW0R38vkce..."      // Credential Id of the public key credential
    }
  ],
  "userVerification": "preferred",          // Default is preferred, can also be set to required or discouraged
  "extensions": {
    "appid": "https://demo.yubico.com"      // AppID extension enables previously registered U2F credentials to authenticate via WebAuthn
  }
};

navigator.credentials.get({ "publicKey": options })
    .then(function (assertion) {
    // Send assertion to server for verification
}).catch(function (err) {
    // No acceptable credential or user refused consent. Handle appropriately.
});
----

Next the browser will validate the parameters and fill in any defaults which will become the clientDataHash. The browser records the origin parameter so that it can be validated on the server later. The authenticator finds a credential that matches the relying party ID and prompts the user to consent to the authentication. Assuming the steps are successful, the authenticator creates a new assertion by signing over the clientDataHash and authenticatorData with the private key generated for this account during the registration call. The authenticator returns the authenticatorData and assertion signature back to the browser. The browser resolves the Promise to a PublicKeyCredential that contains the AuthenticatorAssertionResponse.

.https://github.com/Yubico/java-webauthn-server/blob/01f5295ee2522ad70b9a6199997a0cad7bffdad2/webauthn-server-demo/src/main/java/demo/webauthn/WebAuthnServer.java#L424[Finish authentication]
[source, java]
----
public Either<List<String>, SuccessfulAuthenticationResult> finishAuthentication(String responseJson) {
    logger.trace("finishAuthentication responseJson: {}", responseJson);

    final AssertionResponse response;
    try {
        response = jsonMapper.readValue(responseJson, AssertionResponse.class);
    } catch (IOException e) {
        logger.debug("Failed to decode response object", e);
        return Either.left(Arrays.asList("Assertion failed!", "Failed to decode response object.", e.getMessage()));
    }

    AssertionRequest request = assertRequestStorage.getIfPresent(response.getRequestId());
    assertRequestStorage.invalidate(response.getRequestId());

    if (request == null) {
        return Either.left(Arrays.asList("Assertion failed!", "No such assertion in progress."));
    } else {
        try {
            AssertionResult result = rp.finishAssertion(
                FinishAssertionOptions.builder()
                    .request(request.getRequest())
                    .response(response.getCredential())
                    .build()
            );

            if (result.isSuccess()) {
                try {
                    userStorage.updateSignatureCount(result);
                } catch (Exception e) {
                    logger.error(
                        "Failed to update signature count for user \"{}\", credential \"{}\"",
                        result.getUsername(),
                        response.getCredential().getId(),
                        e
                    );
                }

                return Either.right(
                    new SuccessfulAuthenticationResult(
                        request,
                        response,
                        userStorage.getRegistrationsByUsername(result.getUsername()),
                        result.getWarnings()
                    )
                );
            } else {
                return Either.left(Collections.singletonList("Assertion failed: Invalid assertion."));
            }
        } catch (AssertionFailedException e) {
            logger.debug("Assertion failed", e);
            return Either.left(Arrays.asList("Assertion failed!", e.getMessage()));
        } catch (Exception e) {
            logger.error("Assertion failed", e);
            return Either.left(Arrays.asList("Assertion failed unexpectedly; this is likely a bug.", e.getMessage()));
        }
    }
}
----

Upon receiving the result of the authentication request the server performs the validation of the response by
Using the public key that was stored during the registration request to validate the signature by the authenticator
Verifying the challenge signed by the authenticator matches the challenge that was generated by the server
Checking that the relying party ID is the one expected
The full list of validation steps can be found in the WebAuthn specification.
