== WebAuthn Client Authentication
The RP can also request the user’s permission to perform an authentication operation with an existing credential. The authentication flow looks similar to the registration flow. The primary differences are:

* Authentication does not require user information
* Authentication creates an assertion signed by the previously generated private key that is associated with the relying party rather than signing with the attestation certificate.

<div style="text-align:center">
image::webauthn-authentication-flow-01.svg?sanitize=true[]

[W3C WebAuthn Authentication Flow Figure](https://www.w3.org/TR/webauthn/images/webauthn-authentication-flow-01.svg)
</div>

=== Authentication Flow
**0.** The client initiates a request to authenticate on behalf of the user. 

**1.** The RP builds an instance of the PublicKeyCredentialRequestOptions and returns it to the client. It contains the challenge and the allowCredentials field which contains a list of previously registered credentials that may be used to perform the authentication ceremony.

==== PublicKeyCredentialRequestOptions Example:
[source,javascript]
----
{
  "publicKey": {
    "allowCredentials": [
      {
        "id": "X9FrwMfmzj...",
        "type": "public-key"
      }
    ],
    "challenge": "kYhXBWX0HO5GstIS02yPJVhiZ0jZLH7PpC4tzJI-ZcA=",
    "rpId": "demo.yubico.com",
    "timeout": 30000,
    "userVerification": "discouraged"
  }
}
----

**allowCredentials:** list of public key credentials acceptable to the RP. Credentials can be omitted in username-less authentication scenario. An entry includes the type of the credential and credential id.
challenge: contains a random value generated by the RP from the authenticator to sign as part of the authentication assertion.

**rpId:** relying party identifier claimed by the caller

**timeout:** the time, in milliseconds, that the caller is willing to wait for the call to complete.

**userVerification:** The default value is “preferred”. The “required” value means the operation will fail if the response does not have the UV flag set. The “discouraged” value indicates the RP does not want user verification employed during the operation.

**2.** The JavaScript client calls navigator.credential.get(). The browser validates the rpId against the origin, hashes the clientData, and calls authenticatorGetAssertion method.

**3.** The authenticator finds a credential that matches the Relying Party ID and prompts the user to consent to the authentication. Assuming the steps are successful, the authenticator creates a new assertion by signing over the clientDataHash and authenticatorData with the private key generated for this account during registration.

**4.** The authenticator returns the authenticatorData and assertion signature back to the browser. 

**5.** The browser resolves the Promise to a PublicKeyCredential that contains the AuthenticatorAssertionResponse which is returned to the RP to finalize the authentication

==== PublicKeyCredential Example:
[source,javascript]
----
{
  "id": "X9FrwMfmzj...",
  "response": {
    "authenticatorData": "xGzvgq0bVGR3WR0Aiwh1nsPm0uy085R0v-ppaZJdA7cBAAAACA",
    "clientDataJSON": "eyJjaGFsbG...",
    "signature": "MEUCIQDNrG..."
  },
  "clientExtensionResults": {}
}
----

**id:** The credential identifier.

**response:** contains metadata which can be used the RP to asses the characteristics of the assertion. The **authenticatorData** contains the authenticator data. The **clientDataJSON** contains the JSON-serialized data passed to the authenticator by the client in order to generate the credential. The signature contains the raw signature returned from the authenticator.

**clientExtensionResults:** contains values for zero or more WebAuthn extensions.

==== Parsed authenticatorData Example:
[source,javascript]
----
{
    "authData": {
      "credentialData": {
        "aaguid": "-iuZ3J45QlePkkow0jxBGA==",
        "credentialId": "IQS1B9MRhknwCLYUghMeczuByTwFx2udqC7L-4EKm16TTMFWGJQpFsJqCtSugJeE5gYB_QupaShMh2DzZxRvIQ==",
        "publicKey": {
          "1": 2,
          "3": -7,
          "-1": 1,
          "-2": "ZsGUIeG53MifPb72qqnmC-X-0PLO-bZiNNow3LUHUYo=",
          "-3": "kuBFf3ZcUc-LAFTPIB8e5DaDt2ofJQ3wAB16zHqNUX0="
        }
      },
      "flags": {
        "AT": false,
        "ED": false,
        "UP": true,
        "UV": false
      },
      "rpIdHash": "xGzvgq0bVGR3WR0Aiwh1nsPm0uy085R0v-ppaZJdA7c=",
      "signatureCounter": 8
}
----

**authData:** The authenticator data is a byte array containing data about the make credential operation, including the credential ID and public key.

**credentialData:** the credential data attested by the authenticator.

**aaguid:** An identifier indicating the make and model of the authenticator which is chosen by the manufacturer.

**credentialId:** The credential identifier generated by the authenticator

**publicKey:** The credential public key encoded in [COSE_Key format](https://tools.ietf.org/html/rfc8152). The example is a COSE_Key Elliptic Curve public key in EC2 format. +
 **1:** is the key type. A value of 2 is the EC2 type +
 **3:** is the signature algorithm. A value of -7 is the ES256 signature algorithm +
**-1:** is the curve type. A value of 1 is the P-256 curve +
**-2:** is the x-coordinate as byte string +
**-3:** is the y-coordinate as byte string 

**flags:** The **AT** indicates whether the authenticator added attested credential data. The **ED** flag indicates if the authenticator data has extensions. The **UP** flag indicates if the user is present. The **UV** flag indicates if the user is verified (PIN or Biometric).

**rpIdHash:** a SHA-256 has of the RP ID the credential is scoped to.

**signatureCounter:** is incremented for each successful authenticatorGetAssertion operation. It is used by RPs to aid in detecting cloned authenticators.

==== Parsed clientDataJSON Example:
[source,javascript]
----
{
  "challenge": "kYhXBWX0HO5GstIS02yPJVhiZ0jZLH7PpC4tzJI-ZcA",
  "origin": "https://demo.yubico.com",
  "type": "webauthn.get"
}
----

The **clientDataJSON** object contains the **challenge** sent by the RP, the **origin** of the domain observed by the client, and the **type** of operation performed.

**6.** Upon receiving the result of the authentication request the server performs the validation of the response by:
Using the public key that was stored during the registration request to validate the signature by the authenticator
Verifying the challenge signed by the authenticator matches the challenge that was generated by the server
Checking that the relying party ID is the one expected

The full list of validation steps can be found in the [WebAuthn specification](https://www.w3.org/TR/webauthn/#verifying-assertion).

== Cross Platform Considerations
Most RPs will want a ubiquitous user experience across all platforms, including browsers and mobile/desktop applications. Mobile/desktop application experiences may need to utilize platform-specific client libraries. 

The browser in the figures below encapsulates and hides the CTAP2 implementation from the RP client-side JavaScript application. CTAP2 specifies the transport specific bindings to communicate with authenticators, which are USB, NFC, and Bluetooth. For example, if a browser wanted to enable NFC authenticators then it must either implement the CTAP2 NFC interface or rely on a platform specific library that does.